## JavaScript 基础

### 1.基本数据类型(6，5)

##### Number  

*运算问题，浮点数运算不准确

Number.MIN_VALUE, Number.MAX_VALUE

 5e-324 1.7976931348623157e+308

##### Null (typeof 输出object类型，为空)

##### Undefined(为未定义，typeof 输出undefined类型)

##### String

##### Boolean (true false 输入数字均为数字类型)

引用数据类型：

##### Object



### 强制类型转换：

**->String**

(1).toString()

不会影响原变量，会将转换结果返回

对于null和undefined没有toString()方法

(2).String(b)

变成参数返回该值，null返回"null",undefined返回"undefined"

对于Number和Boolean来说调用的是toString()方法

对于null和undefined不会调用toString()方法

**->Number(数字类型的值在前端为了保持它值的一致，最好在使用前都对它的类型做一个标准转换，否则可能会导致数值不能正确使用，也可能导致浏览器报错)**

(1).Number(a)

纯数值字符串直接转数字

带有字符串转换为NaN形式

字符串为空格会转为0

boolean转换为0/1

(2).字符串转数字

只读到数字结束的位数

parseInt()

parseFloat()

**-> 进制转换**

十六进制：0x

八进制：0

二进制可能会导致浏览器无法识别，IE内核可能会对此有不同处理

**-> Boolean**

（1）Boolean()函数

NaN, null,0 => false

"", undefiend => false

*对象都是true

**-> 普通运算符**

强制类型会先将除String转类型换为Number类型。

任何值与NaN做运算都得NaN。

+:

任何值和字符串相加都会转换为字符串

String使用"+"会直接拼接。

增加空串时可以用作字符串类型转换(隐式类型转换)

例：

Result = 1 + 2 +"3"

Result = "1" + 2 + 3

注意是先做了类型转换还是先做了加减运算，结果可能不一致。

-，*，/ 都会先转换为Number类型  （隐式类型转换2）

*: 

let result = 2 * 2;

// undefined本身 转换为Number类型是NaN

result = 2 * undefined;

// null本身 转换为NaN类型是0

result = 2 * null;

符号 -> 自增(自减同理)

新值：

++a

原值：

a++

例： 陷阱问题

var c = 10; 

c++;

console.log(c++)

例：自增自减理解

​       // var n1 = 10, n2=20;

​        // var n = n1++; // 新值：n1 = 11 原值：n1++ = 10

​        // console.log('n='+n);

​        // //10

​        // console.log('n1='+n1);

​        // //11

​        // n = ++n1; //n1 = 12 ++n1 = 12

​        // console.log('n='+n);

​        // // 12

​        // console.log('n1='+n1);

​        // // 12

​        // n = n2 --;

​        // console.log('n='+n);

​        // //20

​        // console.log('n2='+n2);

​        // //19

​        // n = --n2;

​        // console.log('n='+n);

​        // //18

​        // console.log('n2='+n2);

​        // //18

##### ->逻辑运算(！&&  ||)

隐式类型转换：

为任意数据类型做两次非运算，从其他类型转换为Boolean

(Boolean值)

js中的与（&&）属于短路的与(第一个值为false不看第二个值)

js中的或（||）属于短路的与(第一个值为true不看第二个值)

(非Boolean值)

先转换为Boolean值，再运算(返回值为原值)

与（&&）运算：如果第一个值为true，则返回第二个值

​                          如果第一个值为false,返回第一个值

或（||）运算：如果第一个值为false，则返回第二个值

​                        如果第一个值为true,返回第一个值

##### ->赋值运算符(+=，-=，*=，/=)

##### ->关系运算符(>,<,>=,<=)

对于非数值比较会先转换成数字

如果符号两侧都是字符串，不会转换数字，而会比较字符串中的Unicode编码

任何值和NaN做比较都是false

##### ->相等运算符(==)

将比较值的类型转换为Number类型

Undefined 衍生至null，这两个值做相等判断会返回true

NaN不和任何值相等，包括它本身

isNaN()判断是否为NaN

##### ->不等运算符(!=)

将比较值的类型转换为Number类型

##### ->(===,!==)

不做值的类型转换，类型不同会返回false

##### ->三元运算符

如果比较的值为一个非boolean值那么会先转换成boolean再运算

#### 运算符优先级

##### ()>自增自减>普通运算符>关系运算符>相等，不等运算符>逻辑运算符>赋值运算符>三元运算>,

## 2.语句

代码块：js的代码块只用于分组

条件分支语句：if…else

​                         If…else if …else

​                         switch(条件为true如果不写break会继续向下执行）

​                        *注意switch的判断条件

​                       例：

```javascript
      let num = 69;

      // 方式一

      switch(num/10) {

      case 6:

      console.log('合格');

      break;

      default:

      console.log('不合格');

      break;

      }
```



```javascript
       //方式二

    switch (true) {

          case num >= 60:

          console.log('合格');

          break;

          default:
          
          console.log('不合格');
          
          break;

      }
```

  for循环

  break,continue:

  if语句中不能使用break和continue

  continue,break后边可以跟一个label，这样break会结束指定的循环而不是最近的

  console.time() ,console.timeEnd()可以计算程序运行时间,break,continue语句的使   用可大幅度提高代码性能

## 3.对象

1.对象类型

(1)内建对象

   ES标准中定义的对象，例如Math String Number Boolean 

(2)宿主对象

   BOM DOM

(3)自定义对象

2.对象的创建与销毁

// 构造函数是专门用来创建对象的函数  ,属性名不要求遵守标识符的规范，属性未创建输出值为undefined

// var obj = new Object();

两种对象属性的创建方式：       

```javascript
var obj = new Object();

obj.name = "孙悟空"

// 删除一个对象 

delete obj.name;

obj["234"] = 789

console.log(obj)

console.log(obj["234"])
```

*属性值可以是对象

in运算符 ：输出true或false标明该属性是否在对象中

3.基本数据类型和引用数据类型的区别

基本数据类型的值直接在栈内存中创建，值与值之间独立存在，不会互相影响。

对象的值会被保存在堆内存中，每创建一个新对象就开辟一个空间，变量保存的是对象的**内存地址**。



自己补充一个图





两个基本类型比较的时候比较的是值，引用数据类型比较的是内存地址。

4.对象字面量

//用构造函数创建对象

var obj = new Object();

var obj = {};

## 4.函数

1.函数也是一个对象，需要调用才能使用，typeof检查时会返回function。

//给匿名函数赋值

var fun3 = function(){

}

调用函数时解析器不会检查实参的类型，实参数量少于形参数量，则没有对应实参的形参是undefined

参数可以是函数,函数本身是一个对象。(传参过程中要注意传递的是对象还是对象的返回值 )

例：

fun(fun(a));

fun(a);

立即执行函数：定义完立即执行且只会执行一次

2.调用匿名函数的方法

(var = function(a,b) {

})(113,233);

*返回值的类型

```javascript
function fun3 () {

  function fun4 () {

      console.log(666)

      alert("fun4")

   }

  console.log(999)

  return fun4;

}

// a = fun3();

// a(); 与下方调用内容一致

fun3()();


```

3.作用域

(1)全局作用域

页面打开时创建，页面关闭状态下销毁

全局作用域中有一个全局对象window，我们可以直接使用

创建的变量都会作为window对象属性保存，创建是函数都会作为window对象的方法保存

变量的声明提前：

使用var关键字声明的变量，会在所有代码执行之前被声明(但不会赋值)

(出现undefined而不会报错)

不使用var关键字声明变量，则变量不会被声明提前

函数的声明提前：

使用函数声明形式创建的function函数，它会在所有的代码执行之前就被创建，所以我们可以在函数声明前调用函数

使用函数表达式声明不会有函数声明提前的状况

(2)函数作用域

函数创建时创建函数作用域，函数执行完毕之后函数作用域销毁，每调用一次函数就会创建一个新的函数作用域，它们之间相互独立。在函数作用域中可以访问到全局作用域的变量。在全局作用域中无法访问到函数作用域的变量。

函数作用域定义的函数如果在本层没有被调用则返回上层函数查找，如果上层不存在则会继续向上寻找直至找到全局作用域为止。

在函数中访问全局变量可用window对象。



函数作用域也有声明提前的特性：

使用var关键字声明的变量，会在函数中所有的代码执行之前被声明。

函数在函数作用域中声明也会在声明之前被调用。

函数中不使用var声明的函数都会变成全局变量。

定义形参相当于在函数作用域中声明了变量

例：

Var a = 123;

function ( ) {

  alert(a);

  a=456;

}

fun();

alert(a);

// 答案：undefined  456



Var a = 123;

Function fun(a) {

alert(a);

a = 456;

}

fun(123);

alert(a);

// 123(传入) 123

alert(d);

// undefined

alert(c);

//错误

Var a = 10;

Var b = "hello";

c = true;

Function fun() {

alert("hello")

}

Var d = 35

//刚加载的时候就已经执行了fun(),c虽然未被var定义，但执行后仍会被赋值

## 5.this

解析器在调用函数每次都会向函数内部传递进一个隐含的参数，this指向一个对象，该对象我们称之为函数执行的上下文对象。

根据函数的**调用方式**不同，this会指向不同对象

以函数形式调用时，this永远都是window；

以方法的形式调用时，this就是调用方法的那个对象。

以构造函数形式调用时，this指向新调用的对象。

使用call和apply时，this是它规定的对象。

5.构造函数

构造函数是一个普通函数，创建方式与普通函数没有区别，习惯上首字母大写。构造函数需要用new关键字来调用。

构造函数的执行流程：

(1)、立刻创建一个新对象

(2)、将新建的对象设置为函数中的this

(3)、逐行执行函数中的代码

(4)、返回新建的对象

使用同一个构造函数创建的对象我们称之为一类对象，将一个构造函数称之为一个类。

```javascript
  function Person (a,b,c) {
          this.name = a;
          this.age = b;
          this.fun = function(){
            alert(c)
          }
        }

        var per = new Person("a","b","c");
        console.log(per);
```

使用instanceof检查一个对象是否是一个类的实例。

## 6.原型

* 创建每一个函数时，解析器都会向函数中添加一个属性prototype，这个属性对应一个对象，这个对象对应原型对象。

*  如果函数作为普通函数调用则prototype无用，通过构造函数调用时，它所创建的对象中都会有一个隐含属性。

​        指向该构造函数的原型对象，可以通过__ proto __来访问该属性。

* 原型对象相当于一个公共区域，所有同一个类的实例都可以访问到。

* 原型对象也是对象，所以它也有原型。使用对象的属性或方法时会在自身中寻找。自身有则直接使用。没有则去原型对象中寻找，知道找到Object对象的原型。Object对象的原型没有原型，如果在Object中依然没有原型，贼返回undefined。 —>原型链

​       返回null时访问到了无属性的__ proto __

## 7.toString()

在页面中打印一个对象时，实际上输出的是对象的toString()方法返回值，为对象添加一个toString方法可以不输出[object object]

## 8.垃圾回收(GC)

一个对象没有任何的变量或属性对它进行引用，我们将永远无法操作该对象。这种对象称之为垃圾，这种对象过多时会占用大量的内存空间，导致程序运行变慢。

JS中拥有自动的垃圾回收机制，会自动销毁垃圾对象。我们自身不可以进行垃圾回收操作，只需要将不再使用的对象设置为null。

## 9.数组(typeof 数组时输出object)

数组也是一个对象，和普通对象功能类似，用来存储一些值。

区别：

对象：属性名——属性值

数组：索引——值

对于连续的数组，使用length属性来获取数组的长度(元素个数)。

非连续数组length获取到的是数组最大的索引+1。

利用字面量创建数组

var arr = [1,2,3,4,6]

数组的方法：

shift()

删除数组的第一个元素，并将被删除的元素作为返回值返回

unshift()

在数组开始依次向前添加

pop()

删除最后一个元素并返回剩余值

push()

在最后一个元素后加入新元素

数组的遍历

for

forEach:只支持IE8以上的浏览器

arr.forEach(function ( value, index, arr) ){

// 元素，索引，正在遍历的对象

}

截取：

slice() 原数组不改变返回新数组

splice() 原数组改变，删除数组中指定元素可以用该方法

(第二个值为总共删除的数量,可以在后边添加)

值为负值时向前截取一项

其他：

join()转换成字符串,可指定连字符

concat()合并数组成为新数组

reserve()反转数组,会直接改变原数组

sort() 按unicode编码进行排序，不可对数字进行排序

*sort(a,b):回调函数中需定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数，使用哪个元素调用不确定，但是数组中a一定在b前边。浏览器会根据回调函数的返回值来决定元素的顺序，如果返回一个大于0的值，元素会交换位置；返回小于0的值，元素位置不变，返回0则认为两个元素相等，不交换位置。

升序a-b,降序b-a

## 10.call和apply

函数也是一个对象，它有两个方法，需要通过函数对象来调用。

call()和apply()都会调用函数执行，在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this。call()方法可以将实参在对象之后依次传递，apply()方法需要将实参封装到一个数组中统一传递。

## 11.arguments

与this相似是调用函数时浏览器传入的隐含参数，arguments是一个类数组对象，可通过索引来操作数据,不定义形参也可以通过arguments来使用实参。

有一个callee属性，对应当前正在执行的函数对象。length可以获取类数组对象长度。

## 12.Date()

var d2 = new Date();

var date = d2.getDate();

var day = d2.getDay();

var month = d2.getMonth() + 1;

var year = d2.getFullYear();

//获取时间戳，从1970年1月1日到现在的秒数

var time = d2.getTime();

// 测试代码执行的性能

Date.now()

## 13.Math()

Math()是一个工具类

max() , min()   //最大，最小值

sqrt()  //开方

ceil()

PI  //3.14

abs() //取绝对值

floor() //四舍五入

round() //四舍五入

## 14.包装类

JS中提供三个包装类，通过三个包装类可以将基本数据类型的数据转换为对象。

Number(),

可以将基本数据类型字符串转换为String对象

String(),

可以将基本数据类型的数字转换为Number对象

Boolean()

可以将基本数据类型的布尔值转换为Boolean对象

## 15.字符串

charAt()

根据索引获得字符

charCodeAt()

获取指定位置字符的字符编码(Unicode编码)

formCharCode()

可以根据字符编码去获取字符

concat()

连接多个字符串

indexOf()

该方法可以检索一个字符串中是否含有指定内容

如果字符串中含有该内容，则会返回其第一次出现的索引

lastIndexOf()

从尾部检索

slice()

- 可以从字符串中截取指定内容

- 不会影响原字符串，而是将截取到内容返回

- 参数：

​         第一个，开始位置的索引(包括开始位置)

​         第二个，结束位置的索引(不包括结束位置)

​                     -如果省略第二个参数，则会截取到后边所有的

- 可以传递一个负数作为参数，负数的话将会从后边计算

substring()

-可以用来截取一个字符串，与slice()类似

- 参数：

- 第一个：开始截取位置的索引(包括开始位置)

- 第二个：结束位置的索引(不包括结束位置)

- 不同的是这个方法不能接受负值作为参数

​                如果传递了一个负值，则默认使用0

substr()

- 用来截取字符串

- 参数：

​        截取开始位置的索引

​        截取的长度

split()

- 可以将一个字符串拆分为一个数组

- 参数：

-  需要一个字符串作为参数，将会根据该字符串拆分数组

toUpperCase()

toLowerCase()

## 16.正则表达式

*test()

使用该方法检查一个字符串是否符合正则表达式的规则

返回true和false

*使用字面量来创建正则表达式

正则本身也是对象

#### 语法：

var 变量 = /正则表达式/匹配模式

使用字面量的方式创建更加简单

​      使用构造函数创建更加灵活

*使用 | 表示或者

*[ ]里的内容也是或的关系

[ab] == a | b

[a-z]任意小写

[A-Z]任意大写字母

*^除了

#### 方法：

split()

加上正则表达式用于按指定条件拆分字符串

search()

- 搜索字符串中是否含有指定内容

- 搜索到则会返回第一次出现的索引，没有搜索到则返回-1

- 可以接受一个正则表达式作为参数，会根据正则表达式检索字符串

match()

- 可以跟据正则表达式，从一个字符串中将符合条件的内容提取出来。

- 默认情况下我们的match只会找到第一个符合要求的内容，找到以后停止检索。
- 可设置全局匹配模式，会匹配到所有内容 /[A-Z]/g  或者 /[a-z]/ig

(

​      补充说明：/i(忽略大小写)；/g(全文查找出现的所有匹配字符)；/gi(全文查找，忽略大小写);/ig(全文查找、忽略大小写)

)

replace()

- 可以将字符串中指定内容替换为新的内容

- 参数：

​         1.被替换内容，可以接受一个正则表达式作为参数

​         2.新的内容

- 默认只会替换第一个

#### 量词：

-通过量词可以设置一个内容出现的次数

-量词只对它前边的一个内容起作用

-{n}正好出现n次

-{m,n}出现m-n次

'+'至少一个

'*'0个或多个

'?'0个或1个

^ 表示开头

$ 表示结尾

. 查找单个字符，除了换行和行结束符  查找 . 的话，可以用转义\

```javascript
var reg = /\./;

reg = /\\/;

reg = new RegExp("\\.");

reg = new RegExp("\\\\");
```

\w 任意字母，数字、_   [A-z0-9]

\W 除了字母、数字、_  [^ A-z0-9   

\d 任意的数字

\D 除了数字

\s 空格: 去除所有空格

\S 除了空格

\b 单词边界

\B 除了单词边界

## 17.DOM 文档对象模型

Node 节点：

文档节点：整个HTML文档 #document

元素节点：HTML文档中的HTML标签(格式为HTMLCollection)

属性节点：元素的属性

文本节点：HTML标签中的文本内容 #text



dom查询：

getElementById()

getElementsByName()

getElementsByTagName():返回当前节点指定标签名后代节点



通过具体的元素节点调用

childNodes:包括文本节点在内的所有节点，根据DOM标签间空白也会当成文本节点(除IE8) (格式为Nodelist)

children:可获取当前元素的所有子元素(格式为HTMLCollection)

firstChild:可获取当前元素的第一个子节点(包括空白文本节点)

firstElementChild:获取当前元素的第一个子元素(不支持IE8以下) 

lastChild:可获取当前元素的最后一个子节点(包括空白文本节点)

lastElementChild:获取当前元素的最后一个子元素(不支持IE8以下) 

parentNode: 表示当前节点的父节点

previousSibling: 表示当前节点的前一个兄弟节点

nextSibling: 表示当前节点的后一个兄弟节点

innerHTML ：获取元素内部的HTML标签。对自结束标签，该属性没有意义

innerText: 获取元素内部的文本内容

读取自结束标签元素节点属性：

直接使用元素，属性名：元素.id  元素.name  元素.value

​                         注意:class属性不能采用这种方式

​                                 读取class属性时需要使用元素.className          









